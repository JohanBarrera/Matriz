#include <iostream>

// Definimos un valor constante para el tamaño máximo de la matriz
const int Max = 100;

// Clase Matriz para representar matrices y realizar operaciones sobre ellas
class Matriz {
private:
    int filas;
    int columnas;
    int elementos[Max][Max]; // Arreglo estático para almacenar los elementos de la matriz

public:
    // Constructor para inicializar la matriz con su tamaño
    Matriz(int f, int c) : filas(f), columnas(c) {}

    // Método para leer los elementos de la matriz desde la entrada estándar
    void TamañoMatriz() {
        std::cout << "Introduzca los elementos de la matriz (" << filas << "x" << columnas << "):\n";
        for (int i = 0; i < filas; ++i) {
            for (int j = 0; j < columnas; ++j) {
                std::cout << "Elemento [" << i << "][" << j << "] = ";
                std::cin >> elementos[i][j];
            }
        }
    }

    // Método para mostrar los elementos de la matriz
    void mostrar() const {
        std::cout << "La matriz es:\n";
        for (int i = 0; i < filas; ++i) {
            for (int j = 0; j < columnas; ++j) {
                std::cout << elementos[i][j] << "\t";
            }
            std::cout << std::endl;
        }
    }

     void suma(const Matriz& A, const Matriz& B) {
        for (int i = 0; i < A.filas; ++i) {
            for (int j = 0; j < A.columnas; ++j) {
                elementos[i][j] = A.elementos[i][j] + B.elementos[i][j];
            }
        }
    }

    void resta(const Matriz& A, const Matriz& B) {
        for (int i = 0; i < A.filas; ++i) {
            for (int j = 0; j < A.columnas; ++j) {
                elementos[i][j] = A.elementos[i][j] - B.elementos[i][j];
            }
        }
    }

    void producto(const Matriz& A, const Matriz& B) {
        for (int i = 0; i < A.filas; ++i) {
            for (int j = 0; j < B.columnas; ++j) {
                elementos[i][j] = 0;
                for (int k = 0; k < A.columnas; ++k) {
                    elementos[i][j] += A.elementos[i][k] * B.elementos[k][j];
                }
            }
        }
    }

    // Método para calcular el determinante de la matriz (solo para matrices cuadradas)
    int determinante() const {
        if (filas != columnas) {
            return 0;
        }

        if (filas == 1) {
            return elementos[0][0];
        }

        int det = 0;
        Matriz subMatriz(filas - 1, columnas - 1);

        for (int x = 0; x < columnas; ++x) {
            int subI = 0;
            for (int i = 1; i < filas; ++i) {
                int subJ = 0;
                for (int j = 0; j < columnas; ++j) {
                    if (j == x) continue;
                    subMatriz.elementos[subI][subJ] = elementos[i][j];
                    ++subJ;
                }
                ++subI;
            }
            det += (x % 2 == 0 ? 1 : -1) * elementos[0][x] * subMatriz.determinante();
        }

        return det;
    }

    // Método para comprobar si la matriz es cuadrada
    bool esCuadrada() const {
        return filas == columnas;
    }
};

// Clase abstracta para operaciones de matrices
class Operation {
public:
    virtual void calcular(const Matriz& A, const Matriz& B, Matriz& C) = 0;
    virtual std::string nombreOperacion() const = 0;
    virtual ~Operation() {}
};

// Clases derivadas para operaciones específicas
class SumaMatriz : public Operation {
public:
    void calcular(const Matriz& A, const Matriz& B, Matriz& C) override {
        C.suma(A, B);
    }

    std::string nombreOperacion() const override {
        return "Suma de Matrices";
    }
};

class RestaMatriz : public Operation {
public:
    void calcular(const Matriz& A, const Matriz& B, Matriz& C) override {
        C.resta(A, B);
    }

    std::string nombreOperacion() const override {
        return "Resta de Matrices";
    }
};

class ProductoMatriz : public Operation {
public:
    void calcular(const Matriz& A, const Matriz& B, Matriz& C) override {
        C.producto(A, B);
    }

    std::string nombreOperacion() const override {
        return "Producto de Matrices";
    }
};

class DeterminanteMatriz : public Operation {
public:
    void calcular(const Matriz& A, const Matriz& /* B */, Matriz& C) override {
        if (!A.esCuadrada()) {
            std::cerr << "La matriz no es cuadrada, no se puede calcular el determinante.\n";
            return;
        }
        int det = A.determinante();
        std::cout << "El determinante es: " << det << std::endl;
    }

    std::string nombreOperacion() const override {
        return "Determinante de Matriz";
    }
};

// Clase Calculadora que gestiona las operaciones
class Calculadora {
private:
    Operation* operaciones[4]; // Arreglo estático para almacenar las operaciones
    int numOperaciones;

public:
    Calculadora() : numOperaciones(4) {
        operaciones[0] = new SumaMatriz();
        operaciones[1] = new RestaMatriz();
        operaciones[2] = new ProductoMatriz();
        operaciones[3] = new DeterminanteMatriz(); // Agregamos la nueva operación
    }

    ~Calculadora() {
        for (int i = 0; i < numOperaciones; ++i) {
            delete operaciones[i];
        }
    }

    void mostrarMenu() const {
        std::cout << "Seleccione una operación:\n";
        for (int i = 0; i < numOperaciones; ++i) {
            std::cout << i + 1 << ". " << operaciones[i]->nombreOperacion() << std::endl;
        }
    }

    void ejecutarOperacion(int seleccion, const Matriz& A, const Matriz& B, Matriz& C) {
        if (seleccion < 1 || seleccion > numOperaciones) {
            std::cerr << "Selección no válida.\n";
            return;
        }

        operaciones[seleccion - 1]->calcular(A, B, C);
    }
};

int main() {
    int filasA, columnasA;

    std::cout << "Introduzca el número de filas y columnas de la matriz A:\n";
    std::cin >> filasA >> columnasA;
    Matriz A(filasA, columnasA);
    A.TamañoMatriz();

    Calculadora calc;
    calc.mostrarMenu();
    int seleccion;
    std::cin >> seleccion;

    Matriz B(0, 0); // B es irrelevante para el determinante
    Matriz C(1, 1); // C se utiliza solo para operaciones de suma, resta, producto

    calc.ejecutarOperacion(seleccion, A, B, C);

    return 0;
}

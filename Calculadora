#include <iostream>

const int Max = 100;

class Matriz {
protected:
    int filas;
    int columnas;
    int elementos[Max][Max];

public:
    Matriz(int f, int c) : filas(f), columnas(c) {
        for (int i = 0; i < filas; ++i) {
            for (int j = 0; j < columnas; ++j) {
                elementos[i][j] = 0;
            }
        }
    }

    void leerElementos() {
        std::cout << "Introduzca los elementos de la matriz (" << filas << "x" << columnas << "):\n";
        for (int i = 0; i < filas; ++i) {
            for (int j = 0; j < columnas; ++j) {
                std::cout << "Elemento [" << i << "][" << j << "] = ";
                std::cin >> elementos[i][j];
            }
        }
    }

    void mostrar() const {
        std::cout << "La matriz es:\n";
        for (int i = 0; i < filas; ++i) {
            for (int j = 0; j < columnas; ++j) {
                std::cout << elementos[i][j] << "\t";
            }
            std::cout << std::endl;
        }
    }

    bool esCuadrada() const {
        return filas == columnas;
    }

    bool esCompatibleSumaYResta(const Matriz& B) const {
        return filas == B.filas && columnas == B.columnas;
    }

    bool esCompatibleProducto(const Matriz& B) const {
        return columnas == B.filas;
    }

    int numeroFilas() const { return filas; }
    int numeroColumnas() const { return columnas; }
    int numeroElemento(int i, int j) const { return elementos[i][j]; }
    void numeroElemento(int i, int j, int valor) { elementos[i][j] = valor; }

    int determinante() const {
        if (!esCuadrada()) {
            std::cerr << "La matriz no es cuadrada, no se puede calcular el determinante.\n";
            return 0;
        }

        return 0;
    }
};

class Operation {
public:
    virtual void calcular(const Matriz& A, const Matriz& B, Matriz& C) = 0;
    virtual std::string nombreOperacion() const = 0;
    virtual ~Operation() {}
};

class SumaMatriz : public Operation {
public:
    void calcular(const Matriz& A, const Matriz& B, Matriz& C) override {
        if (A.esCompatibleSumaYResta(B)) {
            for (int i = 0; i < A.numeroFilas(); ++i) {
                for (int j = 0; j < A.numeroColumnas(); ++j) {
                    C.numeroElemento(i, j, A.numeroElemento(i, j) + B.numeroElemento(i, j));
                }
            }
        } else {
            std::cerr << "Las matrices no son compatibles para la suma.\n";
        }
    }

    std::string nombreOperacion() const override {
        return "Suma de Matrices";
    }
};

class RestaMatriz : public Operation {
public:
    void calcular(const Matriz& A, const Matriz& B, Matriz& C) override {
        if (A.esCompatibleSumaYResta(B)) {
            for (int i = 0; i < A.numeroFilas(); ++i) {
                for (int j = 0; j < A.numeroColumnas(); ++j) {
                    C.numeroElemento(i, j, A.numeroElemento(i, j) - B.numeroElemento(i, j));
                }
            }
        } else {
            std::cerr << "Las matrices no son compatibles para la resta.\n";
        }
    }

    std::string nombreOperacion() const override {
        return "Resta de Matrices";
    }
};

class ProductoMatriz : public Operation {
public:
    void calcular(const Matriz& A, const Matriz& B, Matriz& C) override {
        if (A.esCompatibleProducto(B)) {
            for (int i = 0; i < A.numeroFilas(); ++i) {
                for (int j = 0; j < B.numeroColumnas(); ++j) {
                    int valor = 0;
                    for (int k = 0; k < A.numeroColumnas(); ++k) {
                        valor += A.numeroElemento(i, k) * B.numeroElemento(k, j);
                    }
                    C.numeroElemento(i, j, valor);
                }
            }
        } else {
            std::cerr << "Las matrices no son compatibles para el producto.\n";
        }
    }

    std::string nombreOperacion() const override {
        return "Producto de Matrices";
    }
};

class MultiplicacionEscalar : public Operation {
public:
    void calcular(const Matriz& A, const Matriz& /* B */, Matriz& C) override {
        double escalar;
        std::cout << "Ingrese el valor del escalar: ";
        std::cin >> escalar;
        C = A;
        for (int i = 0; i < C.numeroFilas(); ++i) {
            for (int j = 0; j < C.numeroColumnas(); ++j) {
                C.numeroElemento(i, j, C.numeroElemento(i, j) * escalar);
            }
        }
    }

    std::string nombreOperacion() const override {
        return "Multiplicación de Matriz por Escalar";
    }
};

class DeterminanteMatriz : public Operation {
public:
    void calcular(const Matriz& A, const Matriz& /* B */, Matriz& /* C */) override {
        if (!A.esCuadrada()) {
            std::cerr << "La matriz no es cuadrada, no se puede calcular el determinante.\n";
            return;
        }
        int det = A.determinante();
        std::cout << "El determinante es: " << det << std::endl;
    }

    std::string nombreOperacion() const override {
        return "Determinante de Matriz";
    }
};

class Calculadora {
private:
    Operation* operaciones[5];
    int numOperaciones;

public:
    Calculadora() : numOperaciones(5) {
        operaciones[0] = new SumaMatriz();
        operaciones[1] = new RestaMatriz();
        operaciones[2] = new ProductoMatriz();
        operaciones[3] = new MultiplicacionEscalar();
        operaciones[4] = new DeterminanteMatriz();
    }

    ~Calculadora() {
        for (int i = 0; i < numOperaciones; ++i) {
            delete operaciones[i];
        }
    }

    void mostrarMenu() const {
        std::cout << "Seleccione una operación:\n";
        for (int i = 0; i < numOperaciones; ++i) {
            std::cout << i + 1 << ". " << operaciones[i]->nombreOperacion() << std::endl;
        }
    }

    void ejecutarOperacion(int seleccion, Matriz& A, Matriz& B, Matriz& C) {
        if (seleccion < 1 || seleccion > numOperaciones) {
            std::cerr << "Selección no válida.\n";
            return;
        }

        if (seleccion == 4 || seleccion == 5) {
            operaciones[seleccion - 1]->calcular(A, B, C);
        } else {
            operaciones[seleccion - 1]->calcular(A, B, C);
        }

        C.mostrar();
    }
};

int main() {
    int filasA, columnasA, filasB = 0, columnasB = 0;

    std::cout << "Introduzca el número de filas y columnas de la matriz A:\n";
    std::cin >> filasA >> columnasA;
    Matriz A(filasA, columnasA);
    A.leerElementos();

    Calculadora calc;
    calc.mostrarMenu();
    int seleccion;
    std::cin >> seleccion;

    Matriz B(0, 0); // Matriz vacía inicial
    Matriz C(filasA, columnasA);

    if (seleccion >= 1 && seleccion <= 3) {
        std::cout << "Introduzca el número de filas y columnas de la matriz B:\n";
        std::cin >> filasB >> columnasB;
        B = Matriz(filasB, columnasB);
        B.leerElementos();
        if (seleccion == 3) {
            C = Matriz(filasA, columnasB);
        }
    }
    
    calc.ejecutarOperacion(seleccion, A, B, C);

    return 0;
}
